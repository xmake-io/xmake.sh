#!/bin/sh
# A script-only build utility like autotools
#
# Licensed under the Apache License, Version 2.0 (the "License");
# you may not use this file except in compliance with the License.
# You may obtain a copy of the License at
#
#     http:##www.apache.org#licenses#LICENSE-2.0
#
# Unless required by applicable law or agreed to in writing, software
# distributed under the License is distributed on an "AS IS" BASIS,
# WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
# See the License for the specific language governing permissions and
# limitations under the License.
#
# Copyright (C) 2022-present, TBOOX Open Source Group.
#
# @author      ruki
#

#-----------------------------------------------------------------------------
# some constants
#
xmake_sh_projectdir=$(X= cd -- "$(dirname -- "$0")" && pwd -P)
xmake_sh_buildir="build"
xmake_sh_version="1.0"
xmake_sh_verbose=false
xmake_sh_diagnosis=false
xmake_sh_copyright="Copyright (C) 2022-present Ruki Wang, tboox.org, xmake.io."

#-----------------------------------------------------------------------------
# some helper functions
#
_die() {
    echo "$@" 1>&2 ; exit 1
}

_toupper()
{
    echo "$1" | tr '[a-z]' '[A-Z]'
}

_tolower()
{
    echo "$1" | tr '[A-Z]' '[a-z]'
}

_vprint()
{
    if "${xmake_sh_verbose}"; then
        echo "$@"
    fi
}

_dprint()
{
    if "${xmake_sh_diagnosis}"; then
        echo "$@"
    fi
}

_path_filename() {
    local filename=`basename -- "${1}"`
    echo "${filename}"
}

_path_extension() {
    local filename=`_path_filename "${1}"`
    local extension="${filename##*.}"
    echo ".${extension}"
}

_path_basename() {
    local filename=`_path_filename "${1}"`
    local basename="${filename%.*}"
    echo "${basename}"
}

_path_directory() {
    local dirname=`dirname -- "${1}"`
    echo "${dirname}"
}

_path_relative() {
    local rootdir="${1}"
    local absolute_path="${2}"
    local relative_path=`realpath --relative-to=${rootdir} "${absolute_path}"`
    echo "${relative_path}"
}

_path_extension_replace() {
    echo "$1" | sed "s/\..*$/$2/"
}

_path_sourcekind() {
    local extension=`_path_extension "${1}"`
    case "${extension}" in
        .c) sourcekind="cc";;
        .cpp) sourcekind="cxx";;
        .cc) sourcekind="cxx";;
        .ixx) sourcekind="cxx";;
        .m) sourcekind="mm";;
        .mxx) sourcekind="mxx";;
        .S) sourcekind="as";;
        .s) sourcekind="as";;
        .asm) sourcekind="as";;
        *) _die "unknown sourcekind for ${1}" ;;
    esac
    echo "${sourcekind}"
}

_path_toolname() {
    local basename=`_path_basename "${1}"`
    local toolname=""
    case "${basename}" in
        *-gcc) toolname="gcc";;
        gcc) toolname="gcc";;
        *-g++) toolname="gxx";;
        g++) toolname="gxx";;
        *-clang++) toolname="clangxx";;
        clang++) toolname="clangxx";;
        *-clang) toolname="clang";;
        clang) toolname="clang";;
        *-ar) toolname="ar";;
        ar) toolname="ar";;
        *) _die "unknown tool for ${basename}";;
    esac
    echo "${toolname}"
}

# get flag name from toolkind, e.g. cc => cflags, cxx => cxxflags
_get_flagname() {
    local toolkind="${1}"
    local flagname=""
    case "${toolkind}" in
        cc) flagname="cflags";;
        cxx) flagname="cxxflags";;
        as) flagname="asflags";;
        mm) flagname="mflags";;
        mxx) flagname="mxxflags";;
        ar) flagname="arflags";;
        sh) flagname="shflags";;
        ld) flagname="ldflags";;
        *) _die "unknown toolkind(${toolkind})!" ;;
    esac
    echo "${flagname}"
}

# duplicate characters
# e.g. _dupch 10 "." => ...........
_dupch()
{
    local count=${1}
    local ch=${2}
    printf %${count}s | tr " " "${ch}"
}

# is enabled? true, yes, y
_is_enabled()
{
    local value=${1}
    if test "x${value}" = "xtrue"; then
        return 0
    elif test "x${value}" = "xyes"; then
        return 0
    elif test "x${value}" = "xy"; then
        return 0
    fi
    return 1
}

# find file in the given directory
# e.g. _find . xmake.sh
_find() {
    local dir=${1}
    local name=${2}
    local depth=${3}
    if is_host "macosx"; then
        echo `find ${dir} -depth ${depth} -name "${name}"`
    else
        echo `find ${dir} -maxdepth ${depth} -mindepth ${depth} -name "${name}"`
    fi
}

# try run program
_try_run_program()
{
    local program="${1}"
    local argv="${2}"
    if ${xmake_sh_diagnosis}; then
        echo "try running: ${program}" "${argv}"
        "${program}" "${argv}"
    else
        "${program}" "${argv}" >/dev/null 2>&1
    fi
    local ok=$?
    if test "${ok}" -ne "0"; then
        return 1
    fi
    return 0
}

#-----------------------------------------------------------------------------
# map functions
#

# define map, @note we can not use bash/declare to define map, because sh does not support it.
#
# _map "options"
# _map_set "options" "key1" "value1"
# _map_set "options" "key2" "value2"
# _map_set "options" "key2" "value3"
# _map_set "options" "key3" "value3"
# _map_set "options" "key4" "__empty__"
# _map_set "options" "key4" "__empty__"
# _count=`_map_count "options"`
# _keys=`_map_keys "options"`
# echo ${_count}
# for key in ${_keys}; do
#     value=`_map_get "options" ${key}`
#     echo ${key} "->" ${value}
# done
#
# echo "------"
# _map_remove "options" "key3"
# _count=`_map_count "options"`
# _keys=`_map_keys "options"`
# echo ${_count}
# for key in ${_keys}; do
#     value=`_map_get "options" ${key}`
#     echo ${key} "->" ${value}
# done
#
_map()
{
    local name=${1}
    eval _map_${name}_count=0
    eval _map_${name}_keys=""
}

_map_count()
{
    local name=${1}
    local count=$(eval echo \$_map_${name}_count)
    echo ${count}
}

_map_get()
{
    local name=${1}
    local key=${2}
    local value=$(eval echo \$_map_${name}_value_${key})
    if test "x${value}" = "x__empty__"; then
        value=""
    fi
    echo ${value}
}

_map_has()
{
    local name=${1}
    local key=${2}
    local value=$(eval echo \$_map_${name}_value_${key})
    if test "x${value}" != "x"; then
        return 0
    fi
    return 1
}

_map_set()
{
    local name=${1}
    local key=${2}
    local value=${3}
    if ! _map_has ${name} ${key}; then
        local count=`_map_count "options"`
        eval _map_${name}_count=$((${count} + 1))
        local keys=$(eval echo \$_map_${name}_keys)
        keys="${keys} ${key}"
        eval _map_${name}_keys=\${keys}
    fi
    eval _map_${name}_value_${key}=\${value}
}

_map_remove()
{
    local name=${1}
    local key=${2}
    if _map_has ${name} ${key}; then
        local count=`_map_count "options"`
        eval _map_${name}_count=$((${count} - 1))
        eval _map_${name}_value_${key}=""
        local keys=$(eval echo \$_map_${name}_keys)
        local keys_new=""
        for k in ${keys}; do
            if test "x${k}" != "x${key}"; then
                keys_new="${keys_new} ${k}"
            fi
        done
        eval _map_${name}_keys=\${keys_new}
    fi
}

_map_keys()
{
    local name=${1}
    local keys=$(eval echo \$_map_${name}_keys)
    echo ${keys}
}

#-----------------------------------------------------------------------------
# detect default environments
#

# detect hosts
os_host=`uname`
os_host=`_tolower ${os_host}`
if echo "${os_host}" | grep cygwin >/dev/null 2>&1; then
    os_host="cygwin"
fi
if echo "${os_host}" | grep msys >/dev/null 2>&1; then
    os_host="msys"
fi
if echo "${os_host}" | grep darwin >/dev/null 2>&1; then
    os_host="macosx"
fi
if echo "${os_host}" | grep linux >/dev/null 2>&1; then
    os_host="linux"
fi
if echo "${os_host}" | grep freebsd >/dev/null 2>&1; then
    os_host="freebsd"
fi
if echo "${os_host}" | grep bsd >/dev/null 2>&1; then
    os_host="bsd"
fi

# determining host
# e.g.
# if is_host "linux" "macosx"; then
#     ...
# fi
is_host()
{
    for host in $@; do
        if test "x${os_host}" = "x${host}"; then
            return 0
        fi
    done
    return 1
}

# detect host architecture
os_arch=`uname -m | tr '[A-Z]' '[a-z]'`

# set the default target platform and architecture
_target_plat_default=${os_host}
_target_arch_default=${os_arch}
_target_mode_default="release"

# set the default project generator and build program
if is_host "freebsd" "bsd"; then
    _project_generator="gmake"
    _make_program_default="gmake"
    _ninja_program_default="ninja"
elif is_host "msys" "cygwin"; then
    _project_generator="gmake"
    _make_program_default="make.exe"
    _ninja_program_default="ninja.exe"
else
    _project_generator="gmake"
    _make_program_default="make"
    _ninja_program_default="ninja"
fi

# determining target platform
# e.g.
# if is_plat "linux" "macosx"; then
#     ...
# fi
is_plat()
{
    for plat in $@; do
        if test "x${_target_plat}" = "x${plat}"; then
            return 0
        fi
    done
    return 1
}

# determining target architecture
# e.g.
# if is_arch "x86_64" "i386"; then
#     ...
# fi
is_arch()
{
    for arch in $@; do
        if test "x${_target_arch}" = "x${arch}"; then
            return 0
        fi
    done
    return 1
}

# determining target mode
# e.g.
# if is_mode "release"; then
#     ...
# fi
is_mode()
{
    for mode in $@; do
        if test "x${_target_mode}" = "x${mode}"; then
            return 0
        fi
    done
    return 1
}

# determining target toolchain
# e.g.
# if is_toolchain "clang"; then
#     ...
# fi
is_toolchain()
{
    for toolchain in $@; do
        if test "x${_target_toolchain}" = "x${toolchain}"; then
            return 0
        fi
    done
    return 1
}

#-----------------------------------------------------------------------------
# project configuration apis
#

# include the given xmake.sh file or directory
# e.g. includes "src" "tests"
includes()
{
    for path in $@; do
        if test -f "${path}"; then
            xmake_sh_scriptdir=$(dirname -- "${path}")
            . "${path}"
        else
            local xmake_sh_scriptdir_cur=${xmake_sh_scriptdir}
            if test "x${xmake_sh_scriptdir}" != "x"; then
                xmake_sh_scriptdir="${xmake_sh_scriptdir_cur}/${path}"
                . "${xmake_sh_scriptdir}/xmake.sh"
            else
                . "${xmake_sh_projectdir}/${path}/xmake.sh"
            fi
            xmake_sh_scriptdir=${xmake_sh_scriptdir_cur}
        fi
    done
}

#-----------------------------------------------------------------------------
# option configuration apis
#

# define option
option()
{
    if ! ${_loading_options}; then
        return
    fi
    local name=${1}
    local description=${2}
    local default=${3}
    _xmake_sh_options="${_xmake_sh_options} ${name}"
    _map_set "options" "${name}_name" "${name}"
    _map_set "options" "${name}_description" "${description}"
    _map_set "options" "${name}_default" "${default}"
    return 0
}
_map "options"

# has the given option?
_has_option()
{
    local name=${1}
    if _map_has "options" "${name}_name"; then
        return 0
    fi
    return 1
}

# get the given option item
_get_option_item()
{
    local name=${1}
    local key=${2}
    local value=`_map_get "options" "${name}_${key}"`
    echo ${value}
}

# set the given option item
_set_option_item()
{
    local name=${1}
    local key=${2}
    local value=${3}
    if test "x${name}" != "x"; then
        _map_set "options" "${name}_${key}" "${value}"
    else
        _die "please set option in the option scope!"
    fi
}

# get the give option value
_get_option_value()
{
    local name=${1}
    local value=`_get_option_item "${name}" "value"`
    if test "x${value}" = "x"; then
        value=`_get_option_item "${name}" "default"`
    fi
    echo ${value}
}

# set the give option value
_set_option_value()
{
    local name=${1}
    local value=${2}
    _set_option_item "${name}" "value" "${value}"
}

# is config for option
is_config()
{
    if ! ${_loading_targets}; then
        return 1
    fi
    local name=${1}
    local value=${2}
    local value_cur=`_get_option_value "${name}"`
    if test "x${value_cur}" = "x${value}"; then
        return 0
    fi
    return 1
}

# has config for option
has_config()
{
    if ! ${_loading_targets}; then
        return 1
    fi
    local name=${1}
    local value_cur=`_get_option_value "${name}"`
    if _is_enabled ${value_cur}; then
        return 0
    fi
    return 1
}

#-----------------------------------------------------------------------------
# target configuration apis
#

# define target
target()
{
    if ! ${_loading_targets}; then
        return
    fi
    local name=${1}
    _xmake_sh_target_current=${name}
    _xmake_sh_targets="${_xmake_sh_targets} ${name}"
    _map_set "targets" "${name}_name" "${name}"
    return 0
}
target_end()
{
    _xmake_sh_target_current=""
}
_map "targets"

# has the given target?
_has_target()
{
    local name=${1}
    if _map_has "targets" "${name}_name"; then
        return 0
    fi
    return 1
}

# has the given target item
_has_target_item()
{
    local name=${1}
    local key=${2}
    if _map_has "targets" "${name}_${key}"; then
        return 0
    fi
    return 1
}

# get the given target item
_get_target_item()
{
    local name=${1}
    local key=${2}
    local value=`_map_get "targets" "${name}_${key}"`
    echo ${value}
}

# set the given target item
_set_target_item()
{
    local name=${1}
    local key=${2}
    local value=${3}
    if test "x${name}" != "x"; then
        _map_set "targets" "${name}_${key}" "${value}"
    else
        _die "please set target in the target scope!"
    fi
}

# add values to the given target item
_add_target_item()
{
    local name=${1}
    local key=${2}
    local value=${3}
    if test "x${name}" != "x"; then
        local values=`_map_get "targets" "${name}_${key}"`
        values="${values} ${value}"
        _map_set "targets" "${name}_${key}" "${values}"
    else
        _die "please set target in the target scope!"
    fi
}

# is default?
_is_target_default() {
    local name="${1}"
    if _has_target_item "${name}" "default"; then
        local default=`_get_target_item "${target}" "default"`
        if _is_enabled ${default}; then
            return 0
        fi
        return 1
    fi
    return 0
}

# get target basename
_get_target_basename() {
    local name="${1}"
    local basename="${name}"
    if _has_target_item "${name}" "basename"; then
        basename=`_get_target_item "${name}" "basename"`
    fi
    echo "${basename}"
}

# get target extension
_get_target_extension() {
    local name="${1}"
    local extension=""
    if _has_target_item "${name}" "extension"; then
        extension=`_get_target_item "${name}" "extension"`
    elif is_plat "mingw"; then
        local kind=`_get_target_item "${name}" "kind"`
        if test "x${kind}" = "xbinary"; then
            extension=".exe"
        elif test "x${kind}" = "xstatic"; then
            extension=".a"
        elif test "x${kind}" = "xshared"; then
            extension=".dll"
        fi
    else
        local kind=`_get_target_item "${name}" "kind"`
        if test "x${kind}" = "xstatic"; then
            extension=".a"
        elif test "x${kind}" = "xshared"; then
            extension=".so"
        fi
    fi
    echo "${extension}"
}

# get target prefixname
_get_target_prefixname() {
    local name="${1}"
    local prefixname=""
    if _has_target_item "${name}" "prefixname"; then
        prefixname=`_get_target_item "${name}" "prefixname"`
    elif is_plat "mingw"; then
        local kind=`_get_target_item "${name}" "kind"`
        if test "x${kind}" = "xstatic"; then
            prefixname="lib"
        elif test "x${kind}" = "xshared"; then
            prefixname="lib"
        fi
    else
        local kind=`_get_target_item "${name}" "kind"`
        if test "x${kind}" = "xstatic"; then
            prefixname="lib"
        elif test "x${kind}" = "xshared"; then
            prefixname="lib"
        fi
    fi
    echo "${prefixname}"
}

# get target filename
_get_target_filename() {
    local name="${1}"
    local filename=""
    local basename=`_get_target_basename "${name}"`
    local extension=`_get_target_extension "${name}"`
    local prefixname=`_get_target_prefixname "${name}"`
    if _has_target_item "${name}" "filename"; then
        filename=`_get_target_item "${name}" "filename"`
    else
        filename="${prefixname}${basename}${extension}"
    fi
    echo "${filename}"
}

# get target directory
_get_targetdir() {
    local name="${1}"
    local targetdir=""
    if _has_target_item "${name}" "targetdir"; then
        targetdir=`_get_target_item "${name}" "targetdir"`
    else
        targetdir="${xmake_sh_buildir}/${_target_plat}/${_target_arch}/${_target_mode}"
    fi
    echo "${targetdir}"
}

# get target object directory
_get_target_objectdir() {
    local name="${1}"
    local objectdir=""
    if _has_target_item "${name}" "objectdir"; then
        objectdir=`_get_target_item "${name}" "objectdir"`
    else
        objectdir="${xmake_sh_buildir}/.objs/${name}/${_target_plat}/${_target_arch}/${_target_mode}"
    fi
    echo "${objectdir}"
}

# get target file path
_get_target_file()
{
    local name="${1}"
    local filename=`_get_target_filename "${name}"`
    local targetdir=`_get_targetdir "${name}"`
    local targetfile="${targetdir}/${filename}"
    echo "${targetfile}"
}

# get sourcefiles in target
_get_target_sourcefiles() {
    local name="${1}"
    local sourcefiles=`_get_target_item "${name}" "files"`
    echo "${sourcefiles}"
}

# get objectfile in target
_get_target_objectfile() {
    local name="${1}"
    local sourcefile="${2}"
    local filename=`_path_filename "${sourcefile}"`
    local extension=".o"
    if is_plat "mingw"; then
        extension=".obj"
    fi
    filename=`_path_extension_replace "${filename}" "${extension}"`
    local objectdir=`_get_target_objectdir "${name}"`
    local objectfile="${objectdir}/${filename}"
    echo "${objectfile}"
}

# get objectfiles in target
_get_target_objectfiles() {
    local name="${1}"
    local sourcefiles=`_get_target_sourcefiles "${name}"`
    local objectfiles=""
    for sourcefile in ${sourcefiles}; do
        local objectfile=`_get_target_objectfile "${name}" "${sourcefile}"`
        objectfiles="${objectfiles} ${objectfile}"
    done
    echo "${objectfiles}"
}

# get abstract flag for gcc/clang in target
_get_target_abstract_flag_for_gcc_clang() {
    local name="${1}"
    local itemname="${2}"
    local value="${3}"
    local flag=""
    case "${itemname}" in
        defines) flag="-D${value}";;
        udefines) flag="-U${value}";;
        includedirs) flag="-I${value}";;
        *) _die "unknown itemname(${itemname})!" ;;
    esac
    echo "${flag}"
}

# get abstract flags in target
_get_target_abstract_flags() {
    local name="${1}"
    local toolname="${2}"
    local itemname="${3}"
    local values=`_get_target_item "${name}" "${itemname}"`
    local flags=""
    for value in ${values}; do
        local flag=""
        case "${toolname}" in
            gcc) flag=`_get_target_abstract_flag_for_gcc_clang "${name}" "${itemname}" "${value}"`;;
            gxx) flag=`_get_target_abstract_flag_for_gcc_clang "${name}" "${itemname}" "${value}"`;;
            clang) flag=`_get_target_abstract_flag_for_gcc_clang "${name}" "${itemname}" "${value}"`;;
            clangxx) flag=`_get_target_abstract_flag_for_gcc_clang "${name}" "${itemname}" "${value}"`;;
            *) _die "unknown toolname(${toolname})!" ;;
        esac
        if test "x${flag}" != "x"; then
            flags="${flags} ${flag}"
        fi
    done
    echo "${flags}"
}

# get compiler flags in target
_get_target_compiler_flags() {
    local name="${1}"
    local toolkind="${2}"
    local program=`_get_toolchain_toolset "${_target_toolchain}" "${toolkind}"`
    local toolname=`_path_toolname "${program}"`
    local result=""
    local itemnames="defines undefines includedirs"
    for itemname in ${itemnames}; do
        local flags=`_get_target_abstract_flags "${name}" "${toolname}" "${itemname}"`
        if test "x${flags}" != "x"; then
            result="${result} ${flags}"
        fi
    done
    echo "${result}"
}

# get linker flags in target
_get_target_linker_flags() {
    local name="${1}"
    local toolkind="${2}"
    local program=`_get_toolchain_toolset "${_target_toolchain}" "${toolkind}"`
    local toolname=`_path_toolname "${program}"`
    local result=""
    local itemnames="linkdirs links syslinks"
    for itemname in ${itemnames}; do
        local flags=`_get_target_abstract_flags "${name}" "${toolname}" "${itemname}"`
        if test "x${flags}" != "x"; then
            result="${result} ${flags}"
        fi
    done
    echo "${result}"
}

# get archiver flags in target
_get_target_archiver_flags() {
    local name="${1}"
    local toolkind="${2}"
    local program=`_get_toolchain_toolset "${_target_toolchain}" "${toolkind}"`
    local toolname=`_path_toolname "${program}"`
    local flags="-cr"
    echo "${flags}"
}

# get target flags
_get_target_flags() {
    local name="${1}"
    local toolkind="${2}"
    local flags=""
    if test "x${toolkind}" = "xsh"; then
        flags=`_get_target_linker_flags "${name}" "${toolkind}"`
    elif test "x${toolkind}" = "xld"; then
        flags=`_get_target_linker_flags "${name}" "${toolkind}"`
    elif test "x${toolkind}" = "xar"; then
        flags=`_get_target_archiver_flags "${name}" "${toolkind}"`
    else
        flags=`_get_target_compiler_flags "${name}" "${toolkind}"`
    fi
    echo "${flags}"
}

# set kind in target
set_kind()
{
    if ! ${_loading_targets}; then
        return
    fi
    local kind=${1}
    _set_target_item "${_xmake_sh_target_current}" "kind" "${kind}"
}

# set default in target
set_default()
{
    if ! ${_loading_targets}; then
        return
    fi
    local default=${1}
    _set_target_item "${_xmake_sh_target_current}" "default" "${default}"
}

# set filename in target
set_filename()
{
    if ! ${_loading_targets}; then
        return
    fi
    local filename="${1}"
    _set_target_item "${_xmake_sh_target_current}" "filename" "${filename}"
}

# set basename in target
set_basename()
{
    if ! ${_loading_targets}; then
        return
    fi
    local basename="${1}"
    _set_target_item "${_xmake_sh_target_current}" "basename" "${basename}"
}

# set extension in target
set_extension()
{
    if ! ${_loading_targets}; then
        return
    fi
    local extension=${1}
    _set_target_item "${_xmake_sh_target_current}" "extension" "${extension}"
}

# set prefixname in target
set_prefixname()
{
    if ! ${_loading_targets}; then
        return
    fi
    local prefixname=${1}
    _set_target_item "${_xmake_sh_target_current}" "prefixname" "${prefixname}"
}

# set target directory
set_targetdir()
{
    if ! ${_loading_targets}; then
        return
    fi
    local targetdir="${1}"
    _set_target_item "${_xmake_sh_target_current}" "targetdir" "${targetdir}"
}

# set target object directory
set_objectdir()
{
    if ! ${_loading_targets}; then
        return
    fi
    local objectdir="${1}"
    _set_target_item "${_xmake_sh_target_current}" "objectdir" "${objectdir}"
}

# add deps in target
add_deps()
{
    if ! ${_loading_targets}; then
        return
    fi
    for dep in $@; do
        _add_target_item "${_xmake_sh_target_current}" "deps" "${dep}"
    done
}

# add files in target
add_files()
{
    if ! ${_loading_targets}; then
        return
    fi
    for file in $@; do
        if test ! -f "${file}"; then
            file="${xmake_sh_scriptdir}/${file}"
        fi
        file=`_path_relative ${xmake_sh_projectdir} "${file}"`
        _add_target_item "${_xmake_sh_target_current}" "files" "${file}"
    done
}

# add defines in target
add_defines()
{
    if ! ${_loading_targets}; then
        return
    fi
    for define in $@; do
        _add_target_item "${_xmake_sh_target_current}" "defines" "${define}"
    done
}

# add udefines in target
add_udefines()
{
    if ! ${_loading_targets}; then
        return
    fi
    for udefine in $@; do
        _add_target_item "${_xmake_sh_target_current}" "udefines" "${udefine}"
    done
}

# add includedirs in target
add_includedirs()
{
    if ! ${_loading_targets}; then
        return
    fi
    for dir in $@; do
        if test ! -d "${dir}"; then
            dir="${xmake_sh_scriptdir}/${dir}"
        fi
        dir=`_path_relative ${xmake_sh_projectdir} "${dir}"`
        _add_target_item "${_xmake_sh_target_current}" "includedirs" "${dir}"
    done
}

# add links in target
add_links()
{
    if ! ${_loading_targets}; then
        return
    fi
    for link in $@; do
        _add_target_item "${_xmake_sh_target_current}" "links" "${link}"
    done
}

# add syslinks in target
add_syslinks()
{
    if ! ${_loading_targets}; then
        return
    fi
    for syslink in $@; do
        _add_target_item "${_xmake_sh_target_current}" "syslinks" "${syslink}"
    done
}

# add linkdirs in target
add_linkdirs()
{
    if ! ${_loading_targets}; then
        return
    fi
    for dir in $@; do
        if test ! -d "${dir}"; then
            dir="${xmake_sh_scriptdir}/${dir}"
        fi
        dir=`_path_relative ${xmake_sh_projectdir} "${dir}"`
        _add_target_item "${_xmake_sh_target_current}" "linkdirs" "${dir}"
    done
}

#-----------------------------------------------------------------------------
# toolchain configuration apis
#

# define toolchain
toolchain()
{
    if ! ${_loading_toolchains}; then
        return
    fi
    local name=${1}
    _xmake_sh_toolchain_current=${name}
    _xmake_sh_toolchains="${_xmake_sh_toolchains} ${name}"
    _map_set "toolchains" "${name}_name" "${name}"
    return 0
}
toolchain_end()
{
    _xmake_sh_toolchain_current=""
}
_map "toolchains"

# has the given toolchain?
_has_toolchain()
{
    local name=${1}
    if _map_has "toolchains" "${name}_name"; then
        return 0
    fi
    return 1
}

# get the given toolchain item
_get_toolchain_item()
{
    local name=${1}
    local key=${2}
    local value=`_map_get "toolchains" "${name}_${key}"`
    echo ${value}
}

# set the given toolchain item
_set_toolchain_item()
{
    local name=${1}
    local key=${2}
    local value=${3}
    if test "x${name}" != "x"; then
        _map_set "toolchains" "${name}_${key}" "${value}"
    else
        _die "please set toolchain in the toolchain scope!"
    fi
}

# get the give toolchain toolset
_get_toolchain_toolset()
{
    local name=${1}
    local kind=${2}
    local programs=`_get_toolchain_item "${name}" "toolset_${kind}" `
    echo ${programs}
}

# set the give toolchain toolset
_set_toolchain_toolset()
{
    local name=${1}
    local kind=${2}
    local programs="${3}"
    _set_toolchain_item "${name}" "toolset_${kind}" "${programs}"
}

# set toolset in toolchain
set_toolset()
{
    if ! ${_loading_toolchains}; then
        return
    fi
    local kind=${1}
    local programs="${2}"
    _set_toolchain_toolset "${_xmake_sh_toolchain_current}" "${kind}" "${programs}"
}

# clang toolchain
toolchain "clang"
    set_toolset "as" "clang"
    set_toolset "cc" "clang"
    set_toolset "cxx" "clang clang++"
    set_toolset "mm" "clang"
    set_toolset "mxx" "clang clang++"
    set_toolset "ld" "clang++ clang"
    set_toolset "sh" "clang++ clang"
    set_toolset "ar" "ar"
toolchain_end

# gcc toolchain
toolchain "gcc"
    set_toolset "as" "gcc"
    set_toolset "cc" "gcc"
    set_toolset "cxx" "gcc g++"
    set_toolset "mm" "gcc"
    set_toolset "mxx" "gcc g++"
    set_toolset "ld" "g++ gcc"
    set_toolset "sh" "g++ gcc"
    set_toolset "ar" "ar"
toolchain_end

#-----------------------------------------------------------------------------
# load options
#

# load options and toolchains
_load_options_and_toolchains()
{
    _loading_options=true
    _loading_toolchains=true
    _loading_targets=false
    local file=${xmake_sh_projectdir}/xmake.sh
    if test -f "${file}"; then
        includes "${file}"
    else
        # include all xmake.sh files in next sub-directories
        local files=`find ${xmake_sh_projectdir} -maxdepth 2 -mindepth 2 -name "xmake.sh"`
        for file in ${files}; do
            includes "${file}"
        done
    fi
}
_load_options_and_toolchains

# show option usage
_show_options_usage()
{
    for name in ${_xmake_sh_options}; do
        local description=`_get_option_item "${name}" "description"`
        local default=`_get_option_item "${name}" "default"`
        local head="--${name}=`_toupper ${name}`"
        local headsize=${#head}
        local tail="${description}"
        if test "x${default}" != "x"; then
            local defval=${default}
            if test "x${defval}" = "xtrue"; then
                defval="yes"
            elif test "x${defval}" = "xfalse"; then
                defval="no"
            fi
            tail="${tail} (default: ${defval})"
        fi
        local width=24
        local padding_width=$((${width} - ${headsize}))
        local padding=`_dupch ${padding_width} " "`
        echo "  ${head}${padding}${tail}"
    done
}

# show configure usage
_show_usage()
{
echo '
Usage: '"$0"' [<options>...]
Options: [defaults in brackets after descriptions]
Common options:
  --help                  Print this message.
  --version               Only print version information.
  --verbose               Display more information.
  --diagnosis             Display lots of diagnosis information.
  --generator=GENERATOR   Set the project generator. (default: '"${_project_generator}"')
                            - gmake
                            - ninja
  --make=MAKE             Set the make program. (default: '"${_make_program_default}"')
  --ninja=NINJA           Set the Ninja program. (default: '"${_ninja_program_default}"')
  --plat=PLAT             Compile for the given platform. (default: '"${_target_plat_default}"')
                            - msys
                            - cross
                            - bsd
                            - mingw
                            - macosx
                            - linux
  --arch=ARCH             Compile for the given architecture. (default: '"${_target_arch_default}"')
                            - msys: i386 x86_64
                            - cross: i386 x86_64 arm arm64 mips mips64 riscv riscv64 s390x ppc ppc64 sh4
                            - bsd: i386 x86_64
                            - mingw: i386 x86_64 arm arm64
                            - macosx: x86_64 arm64
                            - linux: i386 x86_64 armv7 armv7s arm64-v8a mips mips64 mipsel mips64el
  --mode=MODE             Set the given compilation mode. (default: '"${_target_mode_default}"')
                            - release
                            - debug
  --toolchain=TOOLCHAIN   Set toolchain name.
                            - clang
                            - gcc

Project options:
'"`_show_options_usage`"'
'
    exit 1
}

# show xmake.sh version
_show_version()
{
    echo "xmake.sh v${xmake_sh_version}, A script-only build utility like autotools"
    echo "${xmake_sh_copyright}"
    echo '                         _               _            '
    echo "    __  ___ __  __  __ _| | ______   ___| |__         "
    echo "    \ \/ / |  \/  |/ _  | |/ / __ \ / __| '_  \       "
    echo "     >  <  | \__/ | /_| |   <  ___/_\__ \ | | |       "
    echo "    /_/\_\_|_|  |_|\__ \|_|\_\____(_)___/_| |_|       "
    echo '                                     by ruki, xmake.io'
    echo '                                                      '
    echo '   ðŸ‘‰  Manual: https://xmake.io/#/getting_started     '
    echo '   ðŸ™  Donate: https://xmake.io/#/sponsor             '
    echo '                                                      '
    exit 2
}

# --foo=yes => foo
_parse_argument_name()
{
    echo "${1#*--}" | sed "s/${2-=[^=]*}$//"
}

# --foo=yes => yes
_parse_argument_value()
{
    echo "$1" | sed "s/^${2-[^=]*=}//"
}

# parse input arguments
_handle_option()
{
    local name=`_parse_argument_name ${1}`
    local value=`_parse_argument_value ${1}`
    if test "x${name}" = "xhelp"; then
        _show_usage
        return 0
    elif test "x${name}" = "xversion"; then
        _show_version
        return 0
    elif test "x${name}" = "xverbose"; then
        xmake_sh_verbose=true
        return 0
    elif test "x${name}" = "xdiagnosis"; then
        xmake_sh_diagnosis=true
        return 0
    elif test "x${name}" = "xplat"; then
        _target_plat=${value}
        return 0
    elif test "x${name}" = "xarch"; then
        _target_arch=${value}
        return 0
    elif test "x${name}" = "xmode"; then
        _target_mode=${value}
        return 0
    elif test "x${name}" = "xtoolchain"; then
        _target_toolchain=${value}
        return 0
    elif test "x${name}" = "xgenerator"; then
        _project_generator=${value}
        return 0
    elif test "x${name}" = "xmake"; then
        _make_program=${value}
        return 0
    elif test "x${name}" = "xninja"; then
        _ninja_program=${value}
        return 0
    elif _has_option "${name}"; then
        _set_option_value "${name}" "${value}"
        return 0
    fi
    return 1
}
while test $# != 0; do
    if _handle_option ${1}; then
        shift
    else
        _die "Unknown option: $1"
    fi
done

#-----------------------------------------------------------------------------
# detect platform and toolchains
#

# check platform
_check_platform()
{
    if test "x${_target_plat}" = "x"; then
        _target_plat=${_target_plat_default}
    fi
    if test "x${_target_arch}" = "x"; then
        _target_arch=${_target_arch_default}
    fi
    if test "x${_target_mode}" = "x"; then
        _target_mode=${_target_mode_default}
    fi
    echo "checking for platform ... ${_target_plat}"
    echo "checking for architecture ... ${_target_arch}"
}

# try make
_toolchain_try_make()
{
    local program=${1}
    if _try_run_program "${program}" "--version"; then
        return 0
    fi
    return 1
}

# try ninja
_toolchain_try_ninja()
{
    local program=${1}
    if _try_run_program "${program}" "--version"; then
        return 0
    fi
    return 1
}

# try gcc
_toolchain_try_gcc()
{
    if test "x${_toolchain_try_gcc_result}" = "xok"; then
        return 0
    elif test "x${_toolchain_try_gcc_result}" = "xno"; then
        return 1
    fi

    local kind=${1}
    local program=${2}
    if _try_run_program "${program}" "--version"; then
        _toolchain_try_gcc_result="ok"
        return 0
    fi
    _toolchain_try_gcc_result="no"
    return 1
}

# try g++
_toolchain_try_gxx()
{
    if test "x${_toolchain_try_gxx_result}" = "xok"; then
        return 0
    elif test "x${_toolchain_try_gxx_result}" = "xno"; then
        return 1
    fi

    local kind=${1}
    local program=${2}
    if _try_run_program "${program}" "--version"; then
        _toolchain_try_gxx_result="ok"
        return 0
    fi
    _toolchain_try_gxx_result="no"
    return 1
}

# try clang
_toolchain_try_clang()
{
    if test "x${_toolchain_try_clang_result}" = "xok"; then
        return 0
    elif test "x${_toolchain_try_clang_result}" = "xno"; then
        return 1
    fi

    local kind=${1}
    local program=${2}
    if _try_run_program "${program}" "--version"; then
        _toolchain_try_clang_result="ok"
        return 0
    fi
    _toolchain_try_clang_result="no"
    return 1
}

# try clang++
_toolchain_try_clangxx()
{
    if test "x${_toolchain_try_clangxx_result}" = "xok"; then
        return 0
    elif test "x${_toolchain_try_clangxx_result}" = "xno"; then
        return 1
    fi

    local kind=${1}
    local program=${2}
    if _try_run_program "${program}" "--version"; then
        _toolchain_try_clangxx_result="ok"
        return 0
    fi
    _toolchain_try_clangxx_result="no"
    return 1
}

# TODO try ar
_toolchain_try_ar()
{
    local kind=${1}
    local program=${2}
    return 0
}

# try program
_toolchain_try_program()
{
    local toolchain=${1}
    local kind=${2}
    local program=${3}
    local ok=false
    local toolname=`_path_toolname "${program}"`
    case "${toolname}" in
        gcc) _toolchain_try_gcc "${kind}" "${program}" && ok=true;;
        gxx) _toolchain_try_gxx "${kind}" "${program}" && ok=true;;
        clang) _toolchain_try_clang "${kind}" "${program}" && ok=true;;
        clangxx) _toolchain_try_clangxx "${kind}" "${program}" && ok=true;;
        ar) _toolchain_try_ar "${kind}" "${program}" && ok=true;;
        *) _die "unknown toolname(${toolname})!" ;;
    esac
    if ${ok}; then
        _vprint "checking for ${program} ... ok"
        return 0
    fi
    _vprint "checking for ${program} ... no"
    return 1
}

# try toolset
_toolchain_try_toolset()
{
    local toolchain=${1}
    local kind=${2}
    local description=${3}
    local programs=`_get_toolchain_toolset "${toolchain}" "${kind}"`
    for program in ${programs}; do
        if _toolchain_try_program "${toolchain}" "${kind}" "${program}"; then
            _set_toolchain_toolset "${toolchain}" "${kind}" "${program}"
            echo "checking for the ${description} (${kind}) ... ${program}"
            return 0
        fi
    done
    return 1
}

# try toolchain
_toolchain_try()
{
    local toolchain=${1}
    _vprint "checking for $toolchain toolchain ..."
    if _toolchain_try_toolset "${toolchain}" "cc" "c compiler" &&
       _toolchain_try_toolset "${toolchain}" "cxx" "c++ compiler" &&
       _toolchain_try_toolset "${toolchain}" "as" "assembler" &&
       _toolchain_try_toolset "${toolchain}" "mm" "objc compiler" &&
       _toolchain_try_toolset "${toolchain}" "mxx" "objc++ compiler" &&
       _toolchain_try_toolset "${toolchain}" "ld" "linker" &&
       _toolchain_try_toolset "${toolchain}" "ar" "static library archiver" &&
       _toolchain_try_toolset "${toolchain}" "sh" "shared library linker"; then
        return 0
    fi
    return 1
}

# detect make
_toolchain_detect_make()
{
    if test "x${_make_program}" = "x"; then
        _make_program=${_make_program_default}
    fi
    if _toolchain_try_make "${_make_program}"; then
        echo "checking for make ... ok"
    else
        echo "checking for make ... no"
        _die "make not found!"
    fi
}

# detect ninja
_toolchain_detect_ninja()
{
    if test "x${_ninja_program}" = "x"; then
        _ninja_program=${_ninja_program_default}
    fi
    if _toolchain_try_ninja "${_ninja_program}"; then
        echo "checking for ninja ... ok"
    else
        echo "checking for ninja ... no"
        _die "ninja not found!"
    fi
}

# detect build backend
_toolchain_detect_backend()
{
    if test "x${_project_generator}" = "xgmake"; then
        _toolchain_detect_make
    elif test "x${_project_generator}" = "xninja"; then
        _toolchain_detect_ninja
    fi
}

# detect toolchain
_toolchain_detect()
{
    # detect build backend
    _toolchain_detect_backend

    # detect toolchains
    local toolchains="${1}"
    if test "x${toolchains}" = "x"; then
        if is_plat "macosx"; then
            toolchains="clang gcc"
        else
            toolchains="gcc clang"
        fi
    fi
    for toolchain in ${toolchains}; do
        if _toolchain_try "$toolchain"; then
            _target_toolchain=${toolchain}
            break
        fi
    done
}

# check toolchain
_check_toolchain()
{
    # detect toolchain
    local toolchain=${_target_toolchain}
    _target_toolchain=""
    _toolchain_detect ${toolchain}

    if test "x${_target_toolchain}" != "x"; then
        echo "checking for toolchain ... ${_target_toolchain}"
    else
        echo "checking for toolchain ... no"
        _die "toolchain not found!"
    fi
}

# check all
_check_all()
{
    _check_platform
    _check_toolchain
}
_check_all

#-----------------------------------------------------------------------------
# load project targets
#

# load targets
_load_targets()
{
    _loading_options=false
    _loading_toolchains=false
    _loading_targets=true
    local file=${xmake_sh_projectdir}/xmake.sh
    if test -f "${file}"; then
        includes "${file}"
    else
        # include all xmake.sh files in next sub-directories
        local files=`_find "${xmake_sh_projectdir}" "xmake.sh" 2`
        for file in ${files}; do
            includes "${file}"
        done
    fi
}
_load_targets

#-----------------------------------------------------------------------------
# generate gmake file
#

_gmake_add_header() {
    echo "# this is the build file for this project
# it is autogenerated by the xmake.sh build system.
# do not edit by hand.
" > "${xmake_sh_projectdir}/Makefile"
}

_gmake_add_switches() {
    echo "ifneq (\$(VERBOSE),1)" >> "${xmake_sh_projectdir}/Makefile"
    echo "V=@" >> "${xmake_sh_projectdir}/Makefile"
    echo "endif" >> "${xmake_sh_projectdir}/Makefile"
    echo "" >> "${xmake_sh_projectdir}/Makefile"
}

_gmake_add_flags() {
    local kinds="cc cxx as mm mxx ld sh ar"
    for target in ${_xmake_sh_targets}; do
        for kind in ${kinds}; do
            local flags=`_get_target_flags "${target}" "${kind}"`
            local flagname=`_get_flagname "${kind}"`
            echo `_toupper ${target}_${flagname}`"=${flags}" >> "${xmake_sh_projectdir}/Makefile"
        done
        echo "" >> "${xmake_sh_projectdir}/Makefile"
    done
}

_gmake_add_toolchains() {
    local kinds="cc cxx as mm mxx ld sh ar"
    for kind in ${kinds}; do
        local program=`_get_toolchain_toolset "${_target_toolchain}" "${kind}"`
        echo `_toupper ${kind}`"=${program}" >> "${xmake_sh_projectdir}/Makefile"
    done
    echo "" >> "${xmake_sh_projectdir}/Makefile"
}

_gmake_add_build_object_for_gcc_clang() {
    local kind=`_toupper "${1}"`
    local sourcefile="${2}"
    local objectfile="${3}"
    local flagname="${4}"
    local objectdir=`_path_directory "${objectfile}"`
    echo "\t@mkdir -p ${objectdir}" >> "${xmake_sh_projectdir}/Makefile"
    echo "\t\$(V)\$(${kind}) -c \$(${flagname}) -o ${objectfile} ${sourcefile}" >> "${xmake_sh_projectdir}/Makefile"
}

_gmake_add_build_object() {
    local target=${1}
    local sourcefile="${2}"
    local objectfile="${3}"
    local sourcekind=`_path_sourcekind "${sourcefile}"`
    local program=`_get_toolchain_toolset "${_target_toolchain}" "${sourcekind}"`
    local toolname=`_path_toolname "${program}"`
    local flagname=`_get_flagname "${sourcekind}"`
    flagname=`_toupper "${target}_${flagname}"`
    echo "${objectfile}: ${sourcefile}" >> "${xmake_sh_projectdir}/Makefile"
    echo "\t@echo compiling.${_target_mode} ${sourcefile}" >> "${xmake_sh_projectdir}/Makefile"
    case "${toolname}" in
        gcc) _gmake_add_build_object_for_gcc_clang "${sourcekind}" "${sourcefile}" "${objectfile}" "${flagname}";;
        gxx) _gmake_add_build_object_for_gcc_clang "${sourcekind}" "${sourcefile}" "${objectfile}" "${flagname}";;
        clang) _gmake_add_build_object_for_gcc_clang "${sourcekind}" "${sourcefile}" "${objectfile}" "${flagname}";;
        clangxx) _gmake_add_build_object_for_gcc_clang "${sourcekind}" "${sourcefile}" "${objectfile}" "${flagname}";;
        *) _die "unknown toolname(${toolname})!" ;;
    esac
    echo "" >> "${xmake_sh_projectdir}/Makefile"
}

_gmake_add_build_objects() {
    local target=${1}
    local sourcefiles=`_get_target_sourcefiles "${target}"`
    for sourcefile in ${sourcefiles}; do
        local objectfile=`_get_target_objectfile "${target}" "${sourcefile}"`
        _gmake_add_build_object "${target}" "${sourcefile}" "${objectfile}"
    done
}

_gmake_add_build_target_for_gcc_clang() {
    local kind=`_toupper "${1}"`
    local targetfile="${2}"
    local objectfiles="${3}"
    local flagname="${4}"
    local targetdir=`_path_directory "${targetfile}"`
    echo "\t@mkdir -p ${targetdir}" >> "${xmake_sh_projectdir}/Makefile"
    echo "\t\$(V)\$(${kind}) -o ${targetfile} ${objectfiles} \$(${flagname})" >> "${xmake_sh_projectdir}/Makefile"
}

_gmake_add_build_target_for_ar() {
    local kind=`_toupper "${1}"`
    local targetfile="${2}"
    local objectfiles="${3}"
    local flagname="${4}"
    local targetdir=`_path_directory "${targetfile}"`
    echo "\t@mkdir -p ${targetdir}" >> "${xmake_sh_projectdir}/Makefile"
    echo "\t\$(V)\$(${kind}) \$(${flagname}) ${flags} ${targetfile} ${objectfiles}" >> "${xmake_sh_projectdir}/Makefile"
}

_gmake_add_build_target() {
    local target=${1}
    local targetdir=`_get_targetdir "${target}"`
    local targetfile=`_get_target_file "${target}"`
    local deps=`_get_target_item "${target}" "deps"`
    local objectfiles=`_get_target_objectfiles "${target}"`

    # get linker
    local targetkind=`_get_target_item "${target}" "kind"`
    local toolkind=""
    case "${targetkind}" in
        binary) toolkind="ld";;
        static) toolkind="ar";;
        shared) toolkind="sh";;
        *) _die "unknown targetkind(${targetkind})!" ;;
    esac
    local program=`_get_toolchain_toolset "${_target_toolchain}" "${toolkind}"`
    local toolname=`_path_toolname "${program}"`

    # get linker flags
    local flagname=`_get_flagname "${toolkind}"`
    flagname=`_toupper "${target}_${flagname}"`

    # link target
    echo "${target}: ${targetfile}" >> "${xmake_sh_projectdir}/Makefile"
    echo "${targetfile}: ${deps}${objectfiles}" >> "${xmake_sh_projectdir}/Makefile"
    echo "\t@echo linking.${_target_mode} ${targetfile}" >> "${xmake_sh_projectdir}/Makefile"
    case "${toolname}" in
        gcc) _gmake_add_build_target_for_gcc_clang "${toolkind}" "${targetfile}" "${objectfiles}" "${flagname}";;
        gxx) _gmake_add_build_target_for_gcc_clang "${toolkind}" "${targetfile}" "${objectfiles}" "${flagname}";;
        clang) _gmake_add_build_target_for_gcc_clang "${toolkind}" "${targetfile}" "${objectfiles}" "${flagname}";;
        clangxx) _gmake_add_build_target_for_gcc_clang "${toolkind}" "${targetfile}" "${objectfiles}" "${flagname}";;
        ar) _gmake_add_build_target_for_ar "${toolkind}" "${targetfile}" "${objectfiles}" "${flagname}";;
        *) _die "unknown toolname(${toolname})!" ;;
    esac
    echo "" >> "${xmake_sh_projectdir}/Makefile"

    # build objects
    _gmake_add_build_objects "${target}"
}

_gmake_add_build_targets() {
    local defaults=""
    for target in ${_xmake_sh_targets}; do
        if _is_target_default "${target}"; then
            defaults="${defaults} ${target}"
        fi
    done
    echo "default:${defaults}" >> "${xmake_sh_projectdir}/Makefile"
    echo "all:${_xmake_sh_targets}" >> "${xmake_sh_projectdir}/Makefile"
    echo ".PHONY: default all" >> "${xmake_sh_projectdir}/Makefile"
    echo "" >> "${xmake_sh_projectdir}/Makefile"
    for target in ${_xmake_sh_targets}; do
        _gmake_add_build_target "${target}"
    done
}

_gmake_add_build() {
    _gmake_add_build_targets
}

_gmake_done() {
    echo "Makefile are generated!"
}

# generate build file for gmake
_generate_for_gmake()
{
    _gmake_add_header
    _gmake_add_switches
    _gmake_add_toolchains
    _gmake_add_flags
    _gmake_add_build
    _gmake_done
}

#-----------------------------------------------------------------------------
# generate ninja file
#

# generate build file for ninja
_generate_for_ninja()
{
    _die "Ninja generator has been not supported!"
}

#-----------------------------------------------------------------------------
# generate build file
#

_generate_build_file()
{
    if test "x${_project_generator}" = "xgmake"; then
        _generate_for_gmake
    elif test "x${_project_generator}" = "xninja"; then
        _generate_for_ninja
    else
        _die "unknown generator: ${_project_generator}"
    fi
}
_generate_build_file
